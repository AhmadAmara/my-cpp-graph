// #include <algorithm>#include <vector>#include <iostream>#include <string>#include <ostream>/*	a graph data structure represented as adjacency list*/#pragma oncetemplate <typename T>class Graph{private:	class Vertex;	class Edge;	public:	using OutEdgeList = std::vector<Edge>;	using VertexList = std::vector<Vertex>;	Graph(bool is_directed = false) : m_directed(is_directed){};	size_t add_vertex(const T& data);	bool add_edge(size_t source_id, size_t target_id);	unsigned int get_next_id(){ return cur_id++; };	const VertexList& get_vertices() const { return m_vertices; };	template <typename F>	friend std::ostream& operator << (std::ostream& os, const Graph<F>& graph);private:	const bool m_directed;	VertexList m_vertices;	static unsigned int cur_id;	class Edge	{	public:		Edge(/*const Vertex& source, */const Vertex& target, int weight = 1) :			/*m_source(source),*/ m_target(target), m_weight(weight){}		const Vertex& get_target() const { return m_target; };	private:		/*Vertex m_source;*/  		Vertex m_target;  		int m_weight;	};	class Vertex	{	public:		Vertex(T data, unsigned int id) : m_data(data), m_id(id){};		const T& get_data() const { return m_data; };		size_t get_id() const { return m_id; };		void add_edge(const Vertex& target, int weight);		const OutEdgeList& get_out_edges() const { return m_edges; };	private:		T m_data;		size_t m_id;		OutEdgeList m_edges;	};};// definitionstemplate <typename T>unsigned int Graph<T>::cur_id = 0;template <typename T>inline size_t Graph<T>::add_vertex(const T& data){	size_t id = get_next_id();	m_vertices.push_back(Graph<T>::Vertex(data, id));	return id;}template <typename T>inline bool Graph<T>::add_edge(size_t source_id, size_t target_id){	m_vertices[source_id].add_edge(m_vertices[target_id], 5);	return true;}template <typename T>inline void Graph<T>::Vertex::add_edge(const Vertex& target, int weight){		m_edges.push_back(Graph<T>::Edge(target, weight));	// std::cout << "**" <<m_edges.size() << std::endl;}template <typename T>std::ostream& operator << (std::ostream& os,const Graph<T>& graph){	os<< "Adjacency list :" << std::endl;	for(auto v: graph.get_vertices())	{		os << v.get_data() << " :";		for(auto edge: v.get_out_edges())		{			os << edge.get_target().get_data() << ", ";		}		os << std::endl;	}	return os;}